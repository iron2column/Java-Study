### 并发

> 有了并发就需要考虑多个线程互相干涉的问题

### 一、不正确的访问资源

**你永远都不知道一个线程何时在运行 ! **

>想象一下，你坐在桌边手拿叉子，正要去叉盘子中的最后一片食物，当你的叉子就要够着它时，这片食物突然消失了！因为你的线程被挂起，另一个进餐者进入并吃掉了它。

![image-20211120132054008](https://gitee.com/ming_yang_chen/oss/raw/master/uPic/20211120_2054_image-20211120132054008.png)

- 第一个线程进入`next()`并执行到第一个`++currentEvenValue`，马上准备执行第二个...（也就是准备从奇数1变成偶数1）
- 但是就在这时，第二个线程也执行进入了相同实例的`next()`并也执行了第一个`++currentEvenValue`,所以奇数1被线程2给变成了偶数1
- 只会线程1又执行了第二个`++currentEvenValue`，因此结果从偶数1变成了奇数2，然后线程1就把该值返回给了val
- 后面对val进行计算判断输出并改变了标志符然后线程1就shutdown了，但是线程2还没继续呢



### 二、解决共享资源竞争

**现在我们要想办法解决这种情况**

#### 1.一种方式——加锁

> 防止冲突的方式是当资源被一个任务使用时，在其上**加锁**
>
> 第一个任务在访问到资源时为其加上锁，此后其他任务无法在资源被锁时访问，只能等待执行中的任务使用完资源后解开锁。此后访问的任务依此类推。

序列化访问共享资源

​	意味着在给定时刻只运行一个任务访问共享资源。

​	通过在代码前面加上一条锁语句来实现的，这就是使得在一段时间内只有一个任务可以运行这段代码。

----

#### 2.一种支持——synchronized关键字

> Java提供关键字==synchronized==的形式，为防止资源冲突提供了内置支持

##### 1. 机制：

​	***从线程的角度***：如果某个任务运行到处于一个被`synchronzied`标记的方法的方法体内，那么在线程（从此方法）返回之前，其他所有要调用类中任何标记为`synchronized`方法的线程都要被阻塞——从线程的角度

​	***从对象的角度：***当在对象上调用其任意被`sunchronized`标记的方法时候，此对象会被加锁（所有对象都自动含有单一的锁，亦被称为监视器），这时该对象上的其他synchronized方法只能等到被调用的这个方法执行完毕并释放了锁之后才能被调用——从对象的角度

![image-20211120142246659](https://gitee.com/ming_yang_chen/oss/raw/master/uPic/20211120_0708_20211120_2246_image-20211120142246659.png)

> 所以，对于一个对象的所有带锁的方法，执行时是一锁具锁

> 注意：在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其他任务直接访问域，这样会产生冲突

*如果一个线程已经调用某个synchronized方法并上锁了，此方法体内又去调用了另一个带synchronized方法呢？*

![image-20211120150016828](https://gitee.com/ming_yang_chen/oss/raw/master/uPic/20211120_0016_image-20211120150016828.png)

----

##### 2. 时机:

> 前面我们知道了synchronized的机制，接下来我们应该自问什么时候使用同步呢？

**Brian同步规则**：

​	*如果你正在写一个变量，它可能接下来将：*

* 被另一个线程读取
* 或者正在读取一个上一次已经被另一个线程写过的变量

​	那么必须使用同步，并且，读写线程都必须使用相同的监视器锁同步

为什么？

​	如果类中有超过一个方法在‘处理’临界数据，那么必须同步所以相关的方法，如果值同步一个，那么其他方法将会随意地忽略这个对象锁，并且无任何惩罚的情况下被调用。

> 每个访问临界共享资源的方法都必须被同步，否则他们就不会正确地工作

##### 3. 使用——在方法上：

```java
public class SynchronizedEvenGenerator extends IntGenerator {
    private int currentEvenValue = 0;

    @Override
    public synchronized int next() {
        ++currentEvenValue;
        Thread.yield();
        ++currentEvenValue;
        return currentEvenValue;
    }

    //----------------------------------------
    //编译：javac -d . *.java
    public static void main(String[] args) {
        EvenChecker.test(new SynchronizedEvenGenerator());
    }
}
```



----

#### 3.一种支持——Lock对象

> synchronized使用简单方便，但是也有灵活性不足的方面，因此JavaSE5提供了并发库concurrent的支持，其中之一的locks就提供了与锁相同功能的不同使用支持

将锁实现为一种对象，使用这种锁需要进行==显式==的：1.锁创建; 2.上锁; 3.解锁。

##### 1. 简单使用：

> 需要注意的地方：
>
> 	1. 你必须将`unlock()`放置在try-finally中的finally中；
> 	1. return必须在try中
>
> 你可能会疑问为什么？
>
> ​	结论是：确保unlock()不会过早发生，从而导致数据还没返回就被其他线程获取进行修改
>
> ​	这样做可行的原因是：try-finally语法的支持，finally的内容会在try的return前一步执行再接着执行return。

```java
//依旧使用前面的例子进行改造
public class MutexEvenGenerator extends IntGenerator{
    private final Lock lock = new ReentrantLock();//1.创建锁:可以作为常量唯一的锁

    private int concurrentValue = 0;
    @Override
    public int next() {
        lock.lock();//2.上锁:需要上锁的临界区
        try {
            ++concurrentValue;
            Thread.yield();
            ++concurrentValue;
            return concurrentValue;//return的地方必须在try块中
        }finally {
            //finally会在try执行完和return之前进行执行
            lock.unlock();//3.解锁
        }
    }

    public static void main(String[] args) {
        EvenChecker.test(new MutexEvenGenerator());//由于锁的机制，如果没有问题会一直运行
    }
}
```

#####2.   优点：

1. 相比synchronized失败抛异常，使用lock可以进行异常处理以使系统恢复；

##### 3. 稍复杂场景：

> 通常只有在解决特殊问题时，才使用显式的Lock对象，下面显示一个例子

```java
//在main中进行了两种测试
public class AttemptLocking {
    private Lock lock = new ReentrantLock();
		
  	/**
  	* 一般使用模式
  	*/
    public void untimed_mine() {
        boolean capture = lock.tryLock();//是否获得锁
        if (capture) {//true 获得锁
            try {
                //多线程操作
            } finally {
                lock.unlock();//解锁
            }
        } else {//没有获得锁
            //执行一般的替代操作
        }

    }

    /**
     * 只进行一次trylock() 未获得锁则不再尝试
     */
    public void untimed() {
        boolean capture = lock.tryLock();

        try {
            System.out.println("lock.tryLock() = " + capture);
        } finally {
            if (capture) {
                lock.unlock();//unlock有使用限制，必须是锁的拥有者才能unlock，否则会抛出异常，因此需要注意
            }
        }

    }

    /**
     * 直接进行一次trylock()，如果没有获得则拥有一次在指定时间内再次执行trylock()机会<br/>
     * 前提是当前线程没有在这段时间内被中断
     */
    public void timed() {
        boolean capture = false;
        try {
            capture = lock.tryLock(2, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        try {
            System.out.println("lock.tryLock(2,TimeUnit.SECONDS) = " + capture);
        } finally {
            if (capture) {
                lock.unlock();
            }
        }
    }
  
   //---------------MAIN-----------------
    public static void main(String[] args) {
        final AttemptLocking al = new AttemptLocking();

        al.untimed();
        al.timed();
        /*
        lock.tryLock() = true
        lock.tryLock(2,TimeUnit.SECONDS) = true
         */

        //.............单线程测试锁
        System.out.println();
        //.............多线程测试锁

        new Thread() {
            {
                setDaemon(true);//先行执行
            }
            @Override
            public void run() {
                al.lock.lock();//守护线程抢占了锁
                System.out.println("acquired");
            }
        }.start();
        Thread.yield();//给上面的线程一个机会，多试几次
        al.untimed();
        al.timed();
        /*
        acquired
        lock.tryLock() = false
        lock.tryLock(2,TimeUnit.SECONDS) = false
         */
    }

}
```

> 显式的Lock对象使你可以拥有更细粒度的控制力。
> 更多的场景：
>
> ​	实现专有的同步结构：遍历链表中的节点的节点传递的加锁机制（也称为锁耦合） 。这种遍历代码必须在释放当前节点的锁之前获取下一节点的锁。



### 三、原子性与易变性







