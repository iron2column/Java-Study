### 并发

> 有了并发就需要考虑多个线程互相干涉的问题

### 一、不正确的访问资源

**你永远都不知道一个线程何时在运行 ! **

>想象一下，你坐在桌边手拿叉子，正要去叉盘子中的最后一片食物，当你的叉子就要够着它时，这片食物突然消失了！因为你的线程被挂起，另一个进餐者进入并吃掉了它。

![image-20211120132054008](https://gitee.com/ming_yang_chen/oss/raw/master/uPic/20211120_2054_image-20211120132054008.png)

- 第一个线程进入`next()`并执行到第一个`++currentEvenValue`，马上准备执行第二个...（也就是准备从奇数1变成偶数1）
- 但是就在这时，第二个线程也执行进入了相同实例的`next()`并也执行了第一个`++currentEvenValue`,所以奇数1被线程2给变成了偶数1
- 只会线程1又执行了第二个`++currentEvenValue`，因此结果从偶数1变成了奇数2，然后线程1就把该值返回给了val
- 后面对val进行计算判断输出并改变了标志符然后线程1就shutdown了，但是线程2还没继续呢



### 二、解决共享资源竞争

**现在我们要想办法解决这种情况**

#### 1.一种方式——加锁

> 防止冲突的方式是当资源被一个任务使用时，在其上**加锁**
>
> 第一个任务在访问到资源时为其加上锁，此后其他任务无法在资源被锁时访问，只能等待执行中的任务使用完资源后解开锁。此后访问的任务依此类推。

序列化访问共享资源

​	意味着在给定时刻只运行一个任务访问共享资源。

​	通过在代码前面加上一条锁语句来实现的，这就是使得在一段时间内只有一个任务可以运行这段代码。

----

#### 2.一种支持——synchronized

> Java提供关键字==synchronized==的形式，为防止资源冲突提供了内置支持

##### 1. 机制：

​	***从线程的角度***：如果某个任务运行到处于一个被`synchronzied`标记的方法的方法体内，那么在线程（从此方法）返回之前，其他所有要调用类中任何标记为`synchronized`方法的线程都要被阻塞——从线程的角度

​	***从对象的角度：***当在对象上调用其任意被`sunchronized`标记的方法时候，此对象会被加锁（所有对象都自动含有单一的锁，亦被称为监视器），这时该对象上的其他synchronized方法只能等到被调用的这个方法执行完毕并释放了锁之后才能被调用——从对象的角度

![image-20211120142246659](https://gitee.com/ming_yang_chen/oss/raw/master/uPic/20211120_0708_20211120_2246_image-20211120142246659.png)

> 所以，对于一个对象的所有带锁的方法，执行时是一锁具锁

> 注意：在使用并发时，将域设置为private是非常重要的，否则，synchronized关键字就不能防止其他任务直接访问域，这样会产生冲突

*如果一个线程已经调用某个synchronized方法并上锁了，此方法体内又去调用了另一个带synchronized方法呢？*

![image-20211120150016828](https://gitee.com/ming_yang_chen/oss/raw/master/uPic/20211120_0016_image-20211120150016828.png)

----

##### 2. 时机:

> 前面我们知道了synchronized的机制，接下来我们应该自问什么时候使用同步呢？

**Brian同步规则**：

​	*如果你正在写一个变量，它可能接下来将：*

* 被另一个线程读取
* 或者正在读取一个上一次已经被另一个线程写过的变量

​	那么必须使用同步，并且，读写线程都必须使用相同的监视器锁同步

为什么？

​	如果类中有超过一个方法在‘处理’临界数据，那么必须同步所以相关的方法，如果值同步一个，那么其他方法将会随意地忽略这个对象锁，并且无任何惩罚的情况下被调用。

> 每个访问临界共享资源的方法都必须被同步，否则他们就不会正确地工作

##### 3. 使用：

```java
public class SynchronizedEvenGenerator extends IntGenerator {
    private int currentEvenValue = 0;

    @Override
    public synchronized int next() {
        ++currentEvenValue;
        Thread.yield();
        ++currentEvenValue;
        return currentEvenValue;
    }

    //----------------------------------------
    //编译：javac -d . *.java
    public static void main(String[] args) {
        EvenChecker.test(new SynchronizedEvenGenerator());
    }
}
```



