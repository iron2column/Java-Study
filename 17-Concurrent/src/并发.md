并发
----
> 并发具有可论证的确定性，但是实际上具有不可确定性

## 一、定义任务—`Runnable`接口
> 线程可以驱动任务，因此需要一种描述任务的方式：`Runnable接口`

### 1.定义任务只需要：

1. 实现Runnable接口；
2. 编写run()方法；

```java
public class LiftOff implements Runnable {
    protected int countDown = 10;
    /**
     * 作为本类所有实例的共享数据
     */
    private static int taskCount = 0;
    /**
     * 标注实例序号
     * 作为常量初始化后不被改变
     */
    private final int id = taskCount++;

    public LiftOff() {
    }

    public LiftOff(int countDown) {
        this.countDown = countDown;
    }

    public String status() {
        return "#" + id + "(" + (countDown > 0 ? countDown : "LiftOff!") + "), ";
    }

    @Override
    public void run() {
        while (countDown-- > 0) {
            System.out.print(status());
            Thread.yield();//对线程调度器scheduler的建议，表明自己已准备好被调度执行
        }
    }
}

```

> 通常run()被写成无限循环的形式，直到某个条件使得run()终止，否则一直运行（见后**如何安全的终止线程**）

### 2.启动：

```java
public class MainThread {
    public static void main(String[] args) {
        LiftOff launch = new LiftOff();
        launch.run();
    }
}
```

执行以及debug会发现运行的只有main()线程，并没有创建新的线程。

### 3.知识点：

> 实现Runnable接口的run()方法并没有特别之处（不会产生任何内在的线程能力）。要实现线程行为，必须==显式==地将任务附着到线程上

----

## 二、线程构造器—`Thread`类

> 将Runnable对象转变为工作任务的方式是，将对象提交给Thread构造器

### 1.初体验：

```java
public class BasicThreads {
    public static void main(String[] args) {
      	//将实现Runnable的LiftOff对象给了Thread去构造一个线程执行
        Thread t = new Thread(new LiftOff());
        t.start();
        System.out.println("Waiting for LiftOff");//可以看到该语句在LiftOff执行完期间执行了
    }
}
/*输出：
#0(9), Waiting for LiftOff
#0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(LiftOff!), 
*/
```

执行以及debug后就会发现，本例在同时执行两个线程：

1. ``main()``线程
2. ``被Thread生成的运行LiftOff``线程

### 2.加倍创建多个Thread线程：

```java
public class MoreBasicThreads {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {//几乎同时创建并启动5个线程（不包括main线程）
            new Thread(new LiftOff()).start();
        }
        System.out.println("Waiting for launch");
    }
}
/*输出：
#0(9), #0(8), #1(9), Waiting for launch
#1(8), #3(9), #2(9), #0(7), #1(7), #3(8), #3(7), #4(9), #4(8), #4(7), #3(6), #4(6), #3(5), #4(5), #3(4), #4(4), #3(3), #1(6), #4(3), #4(2), #4(1), #4(LiftOff!), #2(8), #1(5), #3(2), #0(6), #3(1), #1(4), #3(LiftOff!), #2(7), #1(3), #0(5), #2(6), #1(2), #2(5), #0(4), #2(4), #2(3), #2(2), #2(1), #2(LiftOff!), #0(3), #0(2), #0(1), #0(LiftOff!), #1(1), #1(LiftOff!),
*/
```

> 输出说明不同任务的执行在线程被换进换出时混在了一起

> 这种交换时由==线程调度器==自动控制的

### 3.知识点：

>  每次执行的结果大多数情况是不太一样的，这是因为**线程调度机制是非确定性的**

> 较早版本的JDK**不会**频繁对时间切片，因此一个小任务可能会很快执行完

> main()创建Thread对象时，并没有捕获任何对这些对象的引用

> 每个Thread都会注册它自己，因此确实有一个对它的引用，而且垃圾回收器无法在它的任务退出run()并死亡之前擦除它

----

## 三、执行器—`Executor`接口

> Executor是为用户服务的**线程构造器管家**

### 1. 体验ExecutorService：

```java
public class CachedThreadPool {
    public static void main(String[] args) {
        //从Executors这个工具类之间获取一个ExecutorService
        ExecutorService exec = Executors.newCachedThreadPool();

        for (int i = 0; i < 5; i++) {
            exec.execute(new LiftOff());
        }
				
      	//必须进行关闭
        exec.shutdown();
    }
}
/*输出：
#3(9), #4(9), #0(9), #2(9), #3(8), #2(8), #4(8), #3(7), #3(6), #3(5), #3(4), #3(3), #3(2), #2(7), #3(1), #2(6), #1(9), #0(8), #3(LiftOff!), #4(7), #0(7), #1(8), #2(5), #0(6), #4(6), #0(5), #1(7), #0(4), #4(5), #2(4), #4(4), #0(3), #1(6), #0(2), #4(3), #1(5), #2(3), #1(4), #4(2), #1(3), #1(2), #0(1), #0(LiftOff!), #1(1), #4(1), #4(LiftOff!), #2(2), #2(1), #1(LiftOff!), #2(LiftOff!), 
*/
```

> Executor在客户端和任务执行之间提供了一个间接层。也就是说，用户无需再==自主==和==显式==地创建Thread对象进行创建线程进行执行。

> Executor的实现类`ExecutorService`具有服务生命周期，它知道如何构建恰当的上下文来执行Runnable对象

### 2.知识点：

> 调用`shutdown()`可以防止新任务被提交给这个Executor

### 3.再体验之替换线程池类型：

> 在上面我们通过`Executors`获取了其中一种的ExectorService，现在我们换一种

```java
public class FixedThreadPool {
   public static void main(String[] args) {
       //Fixed线程池将指定固定数量的线程数在线程池中
       ExecutorService exec = Executors.newFixedThreadPool(5);
       for (int i = 0; i < 10; i++) {
           exec.execute(new LiftOff());
       }
       exec.shutdown();
   }
}
```

> `FixedThreadPool`可以一次性预先执行代价高昂的线程分配，因而限制线程数量避免资源被滥用

### 4.三体验之替换为SingleThreadExecutor：

```java
public class SingleThreadExecutor {
    public static void main(String[] args) {
        ExecutorService exec = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 5; i++) {
            exec.execute(new LiftOff());
        }
        exec.shutdown();
    }
}
/*
#0(9), #0(8), #0(7), #0(6), #0(5), #0(4), #0(3), #0(2), #0(1), #0(LiftOff!), #1(9), #1(8), #1(7), #1(6), #1(5), #1(4), #1(3), #1(2), #1(1), #1(LiftOff!), #2(9), #2(8), #2(7), #2(6), #2(5), #2(4), #2(3), #2(2), #2(1), #2(LiftOff!), #3(9), #3(8), #3(7), #3(6), #3(5), #3(4), #3(3), #3(2), #3(1), #3(LiftOff!), #4(9), #4(8), #4(7), #4(6), #4(5), #4(4), #4(3), #4(2), #4(1), #4(LiftOff!), 
 */
```

> 向SingleThreadExecutor提交多个任务，则任务会排队执行

> SingleThreadExecutor会序列化所有提交给它的任务，并会维护它自己（隐藏）的悬挂任务队列

### 5.小知识：

> 注意，在任何线程池中，现有线程在可能的情况下，都会被自动复用

> `CacheThreadPool`在程序执行过程中通常会创建所需数量的线程，然后在它回收旧线程时停止创建新线程

> `SingleThreadExecutor`是就像线程数量为1的`FixedThreadPool`

----

